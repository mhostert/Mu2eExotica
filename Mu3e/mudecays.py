import numpy as np
import copy
from phasespace import GenParticle
from particle import literals as lp  # --> MeV units
import hepunits as u  # converting to GeV
import pylhe
import awkward as ak

import os
import multiprocess as mp
from multiprocess import Pool
import concurrent.futures

this_dir = os.path.dirname(os.path.realpath(__file__))

from . import fastmc as fm

# import the amplitude model from each process:
from .mu1e2nu.SubProcesses.P1_mup_vmxveep_no_zh import matrix2py as amp_mu1e2nu
from .mu3e2nu.SubProcesses.P1_mup_vmxveepepem_no_zh import matrix2py as amp_mu3e2nu
from .mu5e2nu.SubProcesses.P1_mup_vmxveepepemepem_no_zh import matrix2py as amp_mu5e2nu

from DarkNews import Cfourvec as Cfv


def mu_PS(x):
    return 1 - 8 * x - 12 * x**2 * np.log(x) + 8 * x**3 - x**4


Gamma_mu = 2.99598e-16  # MeV
# (
#     (1.16e-5 / u.GeV**2) ** 2
#     * (lp.mu_minus.mass / u.MeV) ** 5
#     / (192 * np.pi**3)
#     * mu_PS((lp.e_minus.mass / lp.mu_minus.mass) ** 2)
# )


# Results from MadGraph run:
# 3e2nu seem ok! -- BR ~ 3.6e-5 # from https://arxiv.org/pdf/1811.10965.pdf
Gamma_mu3e2nu = 1.155e-20
BR_mu3e2nu = (Gamma_mu3e2nu / u.MeV) / (Gamma_mu / u.MeV)
# 5e2nu -- no known resul in literature
Gamma_mu5e2nu = 1.342e-25
Gamma_mu5e2nu_20MeVcut = 2.762e-29
Gamma_mu5e2nu_10MeVcut = 3.4522e-31
BR_mu5e2nu = (Gamma_mu5e2nu / u.MeV) / (Gamma_mu / u.MeV)


CHANNELS = ["mu1e2nu", "mu3e2nu", "mu5e2nu", "mu5e"]
BRANCHINGS = [1.0, BR_mu3e2nu, BR_mu5e2nu, None]
AMPLITUDES = [amp_mu1e2nu, amp_mu3e2nu, amp_mu5e2nu, None]
CHANNEL_LATEX_NAMES = [
    r"$\mu^+ \to e^+ \nu_e \overline{\nu}_\mu$",
    r"$\mu^+ \to e^+ e^+e^- \nu_e \overline{\nu}_\mu$",
    r"$\mu^+ \to e^+ e^+e^- e^+e^- \nu_e \overline{\nu}_\mu$",
    r"$\mu^+ \to e^+ e^+e^- e^+e^-$",
]

AMP_DICT = {c: a for c, a in zip(CHANNELS, AMPLITUDES)}
BR_DICT = {c: a for c, a in zip(CHANNELS, BRANCHINGS)}
LATEX_NAMES_DICT = {c: a for c, a in zip(CHANNELS, CHANNEL_LATEX_NAMES)}

PDGID_NAMES = {
    11: "e-",
    -11: "e+",
    13: "mu-",
    -13: "mu+",
    12: "nu_e",
    -14: "nu_mu_bar",
}


def get_P_and_id_from_MG5(filename):
    # self.mg5events = pylhe.read_lhe_with_attributes(self.import_from_mg5)
    mg5events = pylhe.read_lhe(filename)

    # Create akward array objects for convinience
    mg5events = pylhe.to_awkward(mg5events)

    P_grid = np.array(
        [
            np.array(mg5events["particles", "vector", ind])
            for ind in ["t", "x", "y", "z"]
        ]
    )
    P_grid = np.transpose(P_grid, axes=(1, 0, 2)) * 1e3  # convert from GeV to MeV

    return P_grid, mg5events["particles", "id"][0]


class Process:
    """
    Class to store the events generated by `phasespace`
    """

    def __init__(
        self, channel, model=None, n_events=1000, import_from_mg5=False, mg5_cut_eff=1.0
    ):
        """
        Initialize the class and put format the momenta correctly
        """

        if channel not in CHANNELS:
            raise ValueError(
                f"Channel {channel} not recognized. Choose from {CHANNELS}"
            )
        elif channel == "mu5e" and model is None:
            raise ValueError(f"Channel {channel} requires a model to be specified.")
        else:
            self.channel = channel
            self.model = model

        self.n_events = n_events

        self.amp = AMP_DICT[self.channel]
        self.branching = BR_DICT[self.channel]
        self.latex_name = LATEX_NAMES_DICT[self.channel]
        self.n_tracks = int(self.channel[2])
        # If new physics, then calculate it from model class
        if self.channel == "mu5e":
            self.branching = self.model.get_mu5e_BR()

        # Import events from MadGraph instead of phasespace?
        self.import_from_mg5 = import_from_mg5
        self.mg5_cut_eff = mg5_cut_eff
        if self.import_from_mg5:
            self.amp = None

    def initialize_amplitude(self):
        if self.channel != "mu5e" and self.amp is not None:
            self._param_card = f"{this_dir}/{self.channel}/Cards/param_card.dat"
            if not os.path.isfile(self._param_card) and self.amp:
                raise ValueError(
                    f"Param card {self._param_card} for MG5 amplitude not found."
                )

            # amplitude module (already model initialised) from MG@5
            self.alphaS = 0.12  # alpha strong -- not relevant for us.
            self.nhel = 0  # summ over all helicites -- TODO include helicities?

            # model module from MG@5
            try:
                self.amp.initialisemodel(self._param_card)
            except AttributeError:
                print("Model could not be initialized.")

    def generate(self, force_Emiss=None):
        # ------------------------------------------------------
        # # Defining particles involved
        MPARENT = lp.mu_minus.mass / u.MeV
        numubar = GenParticle("nu_mu_bar", 0.0)
        nue = GenParticle("nu_e", 0.0)
        positron_0 = GenParticle("e+_0", lp.e_plus.mass / u.MeV)
        electron_1 = GenParticle("e-_1", lp.e_minus.mass / u.MeV)
        positron_1 = GenParticle("e+_1", lp.e_plus.mass / u.MeV)
        electron_2 = GenParticle("e-_2", lp.e_minus.mass / u.MeV)
        positron_2 = GenParticle("e+_2", lp.e_plus.mass / u.MeV)

        if self.channel == "mu1e2nu":
            # ------------------------------------------------------
            # µ -> ν_mu_bar ν_e e+
            # !! Watch out for the ordering of the particles (following diagrams in MadGraph)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(
                numubar, nue, positron_0
            )
        elif self.channel == "mu3e2nu":
            # ------------------------------------------------------
            # µ -> ν_mu_bar ν_e e+ e+ e-
            # !! Watch out for the ordering of the particles (following diagrams in MadGraph)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(
                numubar,
                nue,
                positron_0,
                positron_1,
                electron_1,
            )

        elif self.channel == "mu5e2nu":
            # ------------------------------------------------------
            # µ -> ν_mu_bar ν_e e+ e+ e- e+ e-
            # !! Watch out for the ordering of the particles (following diagrams in MadGraph)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(
                numubar,
                nue,
                positron_0,
                positron_1,
                electron_1,
                positron_2,
                electron_2,
            )
        elif self.channel == "mu5e":
            # ------------------------------------------------------
            # µ -> e+ (phi -> (aprime -> e+ e-) (aprime -> e+ e-))
            aprime_1 = GenParticle("dp_1", self.model.maprime).set_children(
                electron_1, positron_1
            )
            aprime_2 = GenParticle("dp_2", self.model.maprime).set_children(
                electron_2, positron_2
            )
            phi = GenParticle("phi", self.model.mphi).set_children(aprime_1, aprime_2)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(positron_0, phi)

        elif self.channel == "mu5e1nu1N":
            # ------------------------------------------------------
            # µ -> e+ v (N -> v (aprime -> e+ e-))
            aprime = GenParticle("dp_1", self.model.maprime).set_children(
                electron_1, positron_1
            )
            N = GenParticle("N", self.model.mN).set_children(nue, aprime)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(
                positron_0, N, numubar
            )

        # ------------------------------------------------------
        # Generate the 4 momenta and weights
        if force_Emiss is not None:
            _names = [p.name for p in self.decay_chain.children]

            self.particles = {name: np.empty((0, 4)) for name in _names}
            self.w_phasespace = np.empty(0)

            n_collected = 0
            _w_total = 0
            while n_collected <= self.n_events:
                _weights, _, _particles = self.decay_chain.generate(
                    n_events=10_000, normalize_weights=False
                )

                _Emiss_true = _particles["nu_mu_bar"][:, -1] + _particles["nu_e"][:, -1]
                _mask = _Emiss_true < force_Emiss

                for p, momenta in _particles.items():
                    self.particles[p] = np.append(
                        self.particles[p], momenta[_mask], axis=0
                    )
                self.w_phasespace = np.append(self.w_phasespace, _weights[_mask])
                _w_total += np.sum(_weights)
                n_collected += np.sum(_mask)

            # Update the number of events
            self.n_events = len(self.w_phasespace)
            self.eff_sampling = np.sum(self.w_phasespace) / _w_total

        else:
            if not self.import_from_mg5:
                self.w_phasespace, _, self.particles = self.decay_chain.generate(
                    n_events=self.n_events, normalize_weights=False
                )
                self.eff_sampling = 1.0

            else:  # IMPORT FROM MADGRAPH
                if isinstance(self.import_from_mg5, list):
                    self.P_grid, self.pids = get_P_and_id_from_MG5(
                        self.import_from_mg5[0]
                    )
                    for mg5file in self.import_from_mg5[1:]:
                        P, _ = get_P_and_id_from_MG5(mg5file)
                        self.P_grid = np.append(self.P_grid, P, axis=0)

                else:
                    self.P_grid, self.pids = get_P_and_id_from_MG5(self.import_from_mg5)

                self.p_parent = self.P_grid[:, :, 0]

                self.n_events = np.shape(self.P_grid)[0]

                # Follow our naming convention
                self.particle_names = np.array([PDGID_NAMES[pid] for pid in self.pids])
                for p in np.unique(self.particle_names):
                    if p[0] == "e":
                        new_names = []
                        for occurrence, _ in enumerate(
                            self.particle_names[self.particle_names == p]
                        ):
                            new_names.append(
                                p + "_" + str(occurrence + int(p[-1] == "-"))
                            )
                        self.particle_names[self.particle_names == p] = new_names

                self.daughter_names = list(
                    self.particle_names[self.particle_names != "mu+"]
                )
                self.particle_names = list(self.particle_names)

                # Main particle dictionary
                self.particles = {
                    name: self.P_grid[:, :, i]
                    for i, name in enumerate(self.particle_names)
                }

                # Phase space weight is uniform
                self.w_phasespace = np.ones(self.n_events) * 1 / self.n_events
                self.eff_sampling = self.mg5_cut_eff

        # work with numpy
        self.w_phasespace = np.array(self.w_phasespace)

        if not self.import_from_mg5:
            # list of daughter particles
            self.daughter_names = list(self.particles.keys())

            # 4-momentum of the parent particle
            # self.p_parent = np.zeros_like(self.particles[self.daughter_names[0]])
            self.p_parent = np.zeros_like(self.particles["e+_0"])
            self.p_parent[:, -1] += MPARENT

            self.put_energy_first()

            self.P_grid = self.build_P_grid()
            self.particle_names = ["mu+"] + list(self.particles.keys())
            self.particles = {}
            for name in self.particle_names:
                self.particles[name] = self.P_grid[
                    :, :, self.particle_names.index(name)
                ]

    def get_track_momenta(self):
        self.tracks = {}

        for name, p in self.particles.items():
            # if electron or positron, then propagate in magnetic field
            if "e+" in name or "e-" in name:
                self.tracks[name] = p
        return self.tracks

    def put_energy_first(self):
        # We need to rearrange the arrays so the first enetry is energy, and not px:
        # `phasespace` indices: 0 -> px, 1 -> py, 2 -> pz, 3 -> E
        # `MadGraph` and `DarkNews` indices: 0 -> E, 1 -> px, 2 -> py, 3 -> pz
        # when rearranging, also convert from TensorFlow object to numpy array
        for k in self.daughter_names:
            self.particles[k] = np.array(self.particles[k])[:, [3, 0, 1, 2]]
        self.p_parent = self.p_parent[:, [3, 0, 1, 2]]

    def build_P_grid(self):
        # dim 0: event number
        # dim 1: lorentz index
        # dim 2: particle number

        # Ordering --> Parent + daughters(following MadGraph convention)
        return np.transpose(
            [self.p_parent] + [self.particles[k] for k in self.daughter_names],
            axes=(1, 2, 0),
        )

    def amp_in_P(self, P):
        if self.amp:
            if self.channel == "mu5e":
                return np.ones(np.shape(P)[0])
            else:
                return self.amp.get_value(P, self.alphaS, self.nhel)

    def evaluate_amplitude(self):
        if self.amp:
            self.w_amp = np.array(
                [
                    self.amp.get_value(self.P_grid[i], self.alphaS, self.nhel)
                    for i in range(self.n_events)
                ]
            )
        else:
            self.w_amp = np.ones((self.n_events,))

        self.weights = (
            self.w_amp
            * self.w_phasespace
            / np.sum(self.w_amp * self.w_phasespace)
            * self.branching
            * self.eff_sampling
        )

    def place_it_in_Mu3e(self):
        self.pos, self.w_target = fm.get_decay_positions_in_target(self.n_events)
        self.x, self.y, self.z = self.pos.T
        self.weights = (
            self.w_target
            * self.weights
            / np.sum(self.w_target * self.weights)
            * self.branching
            * self.eff_sampling
        )

        self.n_hits = {name: np.zeros(self.n_events) for name in self.particles.keys()}
        self.n_short_tracks = np.zeros(self.n_events)
        self.n_long_tracks = np.zeros(self.n_events)

        self.n_short_tracks_minus = np.zeros(self.n_events)
        self.n_long_tracks_minus = np.zeros(self.n_events)

        for name, p in self.particles.items():
            # if electron or positron, then propagate in magnetic field
            if "e+" in name or "e-" in name:
                E = p[:, 0]
                pT = np.sqrt(p[:, 1] ** 2 + p[:, 2] ** 2)
                pL = p[:, 3]
                pmag = np.sqrt(pT**2 + pL**2)

                # velocity
                beta_L = pL / E
                beta_T = pT / E

                # Angle wrt the z axis
                theta = np.arccos(pL / pmag)
                angle_lambda = np.pi / 2 - theta

                # xy plane angle
                phi = np.arctan2(p[:, 2], p[:, 1])

                # Radius of the arc trajectory
                arc_R = fm.radius_of_curvature(pT, Bfield=1.0)

                # Time to exit from the detector in z coordinate
                _t_exit = fm.time_of_exit(self.z, beta_L)

                # Maximum arc-angle of the trajectory (>= 2pi if fully recurled)
                _max_arc_angle = np.where(
                    arc_R > 0,
                    _t_exit
                    * np.abs(beta_T)
                    * fm.c_light
                    / (2 * np.pi * arc_R)
                    * 2
                    * np.pi,
                    0,
                )

                # distance from the beam axis at exit point
                _chord_length = np.sqrt(2) * arc_R * np.sqrt(1 - np.cos(_max_arc_angle))
                _max_chord_length = (
                    np.sqrt(2)
                    * arc_R
                    * np.sqrt(1 - np.cos(np.minimum(_max_arc_angle, np.pi)))
                )

                # FIX-ME -- correct this with the appropriate angle between chord and beam-radius.
                _transv_pos_at_exit = _chord_length + fm.r(self.x, self.y)
                _max_transv_pos = _max_chord_length + fm.r(self.x, self.y)

                # Time until the track is recurled
                _t_recurl = fm.time_of_recurl(arc_R, beta_T)
                _z_recurl = _t_recurl * beta_L * fm.c_light

                hit_recurler = (
                    np.abs(_z_recurl) > fm.recurler_L / 2 + fm.outer_recurler_gap
                ) & (
                    np.abs(_z_recurl)
                    < fm.recurler_L / 2 + fm.recurler_L + fm.outer_recurler_gap
                )

                _short_track = _max_transv_pos >= fm.layer4_R
                _long_track = _short_track & (_transv_pos_at_exit < fm.layer4_R)

                # Did it hit the inner cylinder?
                self.n_hits[name][_short_track] += 4

                # Did it hit the outer cylinder?
                self.n_hits[name][_long_track] += 2
                self.n_hits[name] += 2 * (
                    _long_track & (_transv_pos_at_exit < fm.layer2_R)
                )

                self.n_short_tracks += 1 * _short_track
                self.n_long_tracks += 1 * _long_track

                if "e-" in name:
                    self.n_short_tracks_minus += 1 * _short_track
                    self.n_long_tracks_minus += 1 * _long_track

        # did it pass selection criteria?
        self.signal_event = self.n_short_tracks == self.n_tracks
        self.particles_true = copy.deepcopy(self.particles)  # Copy it
        self.particles = fm.smear_samples(self.particles, self.n_hits)

        self.get_track_momenta()
        self.Etot = np.zeros(self.n_events)
        self.total_eminus_energy = np.zeros(self.n_events)
        self.total_inv_mass = np.zeros(self.n_events)
        self.p_total = np.zeros((self.n_events, 4))
        for name, track in self.tracks.items():
            self.Etot += track[:, 0]
            if "e-" in name:
                self.total_eminus_energy += track[:, 0]

            self.p_total += track

        self.Emiss = self.p_parent[:, 0] - self.Etot
        self.total_inv_mass = Cfv.inv_mass(self.p_total, self.p_total)
